\section{OCaml} % Implementación en OCaml
\hspace{1.5em}Compiler used: \texttt{ocamlc} version 4.02.3 together with the bytecode interpreter \texttt{ocamlrun}.

\subsection{Language Survey} % Descripción
\hspace{1.5em}OCaml (Objective Caml) is a general-purpose high-level programming language that follows mainly the functional paradigm, but it has imperative and object-oriented facilities too. Being a member of the ML (Meta Language) family, OCaml is the current implementation of Caml (Categorical abstract machine language).\\ % OCaml (Objetive Caml) es un lenguaje de programación de alto nivel de propósito general que sigue principalmente el paradigma declarativo funcional, pero contiene métodos para la programación imperativa estructurada y orientación a objetos basada en clases. Basado en los Meta-Lenguajes, OCaml es la actual implementación de Caml (Categorical abstract machine language). \\

The source code can be compiled to bytecode which is then executed in an interpreter (\texttt{ocamlc} and \texttt{ocamlrun} respectively). Another option is to use the native code compiler \texttt{ocamlopt}, which produces machine code for the final platform. Interactive use of OCaml is allowed through the toplevel system \texttt{ocaml}, which repeatedly reads OCaml phrases from the input, then typechecks, compiles and evaluates them, then prints the inferred type and result value, if any.\\ % El código fuente se puede compilar a bytecode para ser ejecutado sobre un intérprete top-level\footnote{El compilador es \texttt{ocamlc} y el intérprete top-level que ejecuta el código es \texttt{ocamlrun}.} que es el que está diseñado para la plataforma final, o también se puede utilizar el compilador stand-alone\footnote{El compilador es \texttt{ocamlopt} y se ejecuta en la propia máquina.} que proporciona código máquina para la plataforma final. \\

The native compiler and the top-level interpreter are responsible for managing the dynamic memory during compilation and execution, that is, there is no manual memory management.\\

OCaml's typing is static, strong and inferred, and allows to define polymorphic variables and data types.

 % Aunque es un lenguaje de tipado estático y fuerte, OCaml presenta un motor inferencial de tipos, pudiendo definir variables y tipos de datos polimórficos. El compilador nativo y el intérprete top-level son los responsables de la gestión y asignación de memoria al compilar y en la ejecución de código OCaml, es decir, no existe gestión manual de la memoria.

\subsection{Analysis}

\subsubsection{Advantages and Disadvantages} % Análisis de ventajas y desventajas
% TODO en el report que corresponda (supongo que este, poner que ha sido la adaptación que dio más problemas)
\hspace{1.5em}As OCaml does not have manual memory management, we have the same implications as in Java in this aspect.\\% Al igual que en Java, no disponemos de gestión de memoria manual, con las implicaciones ya mencionadas.\\

The way the tree is implemented in Pascal does not favor the use of functional programming in such a way that iterative and recursive implementations can be used interchangeably, so it was necessary to stay away from this kind of programming.\\ % El modo en el que el árbol está implementado en Pascal no favorece el uso de la programación funcional de una forma tal que las versiones iterativas y recursivas sean intercambiables, por lo que fue necesario apartarse un tanto de este tipo de programación.\\ 

Another thing to mention is that the matching system OCaml provides simplifies implementation as we use it to replace the first if-then-else statement, thus allowing us to obtain the components of a \texttt{Node} without using the other functions, which ultimately increases the readability of the source code. % Por otro lado, el sistema de matching que ofrece OCaml simplifica la implementación ahorrando el if-then-else inicial

\subsubsection{Implementation} % Análisis de implementacitón
% TODO plantearse definir el tipo tKey
\hspace{1.5em}The tree is represented by the type \texttt{bst}. This type can have two different values: \texttt{Empty} and \texttt{Node(int, bst ref, bst ref)}. Using \texttt{bst ref} as left and right children allow us to manipulate them in a somewhat similar way to Pascal's pointers. A \texttt{ref} is a structure containing a field \texttt{contents}, which is the information that is actually modified (equivalent to the pointer's content in some way).\\ % Nuestro árbol se representa mediante el tipo \texttt{bst}, que puede tomar los valores \texttt{Empty} y \texttt{Node(int, bst ref, bst ref)}. Utilizar \texttt{bst ref} como hijos derecho e izquierdo nos permite manejarlos de una manera en cierto modo similar a los punteros de Pascal. Una \texttt{ref} es una estructura con un campo \texttt{contents}, que es la información que realmente se modifica (una especie de equivalente al contenido del puntero).\\ 
With regard to the functions, we have the following: % Con respecto a las funciones, tenemos lo siguiente:
\begin{itemize}
	\item \texttt{arbolVacio:} Receives \texttt{unit} (the equivalent to void in OCaml) and returns a \texttt{ref} containing \texttt{Empty}. % Recibe \texttt{unit}\footnote{El equivalente al vacío en OCaml} y devuelve una ref a Empty.
	\item \texttt{hijoIzquierdo, hijoDerecho} and \texttt{raiz:} They match the tree's content with a Node(key,left,right) and return the pertinent component. Like in Pascal, they fail if the tree is empty. % Matchean el contenido del árbol con un Node(key,left,right) y devuelven el componente que corresponda. Al igual que en la implementación en Pascal, fallan si el árbol de entrada está vacío.
	\item \texttt{esArbolVacio:} Returns true if the tree's content is \texttt{Empty} and false otherwise. % Si el contenido del árbol es Empty devuelve true, en cualquier otro caso devuelve false.
	% TODO comprobar que de verdad la adaptacion es directa
	\item \texttt{insertar\_r, insertar\_i, buscar\_r} and \texttt{buscar\_i:} The adaptation is direct.
	\item \texttt{sup2:} It is implemented as a local function. Receives the node used to traverse the tree while searching for the node with the greatest key, and the parent node to that first argument. In this way, once the node with the greatest key is found, we use that key to replace the one we are going to delete, and then reorganize its left child via its parent node. % Recibe el nodo utilizado para recorrer el árbol en busca del nodo con mayor clave, y el nodo padre de este. De este modo, una vez encontrado el nodo con mayor clave, usamos dicha clave para sustituir a la que se va a eliminar, y mediante el nodo padre recolocamos sus hijos izquierdos en el árbol resultado.
	\item \texttt{eliminar\_r:} A \texttt{unit} is returned if the received tree is empty. Leaving that aside, the adaptation from Pascal is done without relevant changes, apart from those mentioned in the auxiliary function. % Se devuelve un unit si el árbol de entrada está vacío (es decir, si la clave no está en el árbol). En caso contrario, la adaptación desde Pascal se realiza sin cambios relevantes, a excepción de la función auxiliar \texttt{sup2} ya comentada.
	\item \texttt{eliminar\_i:} The adaptation is almost direct, but we introduce a new auxiliary variable: \texttt{parentMaxLeftChild}, which represents \texttt{maxLeftChild}'s parent node. It fulfills the role of \texttt{parentRm} in Pascal, only in the section where \texttt{maxLeftChild} is used, obviously. \texttt{parentRm} is used to change the key of the node to delete, as \texttt{rm} is just a ``copy'' of the node we actually want to modify\footnote{Note: Whenever an iterator variable is needed (that is, a variable for traversing the tree) it is created as a \texttt{ref} to the \texttt{bst} argument's content in order to have a copy of the node, thus preventing any undesired changes to the tree structure during traversal.}. If \texttt{parentRm} is \texttt{Empty} (that is, the node to be removed is the root of the whole tree) we modify the tree passed as an argument to the function. % La adaptación es casi directa, salvo por la introducción de una nueva variable auxiliar: parentMaxLeftChild, que representa al nodo padre de maxLeftChild y cumple con las funciones que correspondían a parentRm en Pascal. Por su parte, parentRm se reserva para cambiar la clave del nodo a eliminar desde ahí, ya que rm es una ``copia'' del nodo que realmente queremos modificar. Si parentRm es Empty (es decir, se va a eliminar la raíz del árbol) modificamos directamente a través del árbol pasado por parámetro.
\end{itemize}

\subsubsection{Possible Enhancements} % Posibles mejoras
\hspace{1.5em} Like in Java, in OCaml we could have defined a binary search tree for a generic key type (specified as 'a in the type definition).\\ % Al igual que en Java, en OCaml podría definirse un árbol binario de búsqueda para un tipo de clave genérico (especificado como 'a en la definición del tipo).\\

On the other hand, because it is required to stick to Pascal's implementation, we could not use the functional paradigm. Should we have done that, we would have had a more intuitive recursive implementation given the language. It would have been simpler and easier to implement as well, as we would not have needed to use refs. However, the iterative version would have been impossible to implement this way.\\ % Por otro lado, el tener que mantenerse fiel a la implementación en Pascal no nos ha permitido utilizar el paradigma funcional propiamente dicho. De haberlo hecho de esta forma, habríamos tenido una implementación recursiva más intuitiva para el lenguaje y más sencilla al no tener que manejar el equivalente a punteros, si bien la iterativa resultaría imposible de realizar.

Our first intent at translating from Pascal to OCaml followed a functional approach, as we started implementing the recursive version because we knew it was going to be easier than the iterative one. As said above, from this definition we could not implement the iterative version, but we have included the files anyway as an example of a more appropiate recursive implementation for OCaml. % TODO si acaso mencionar que no es perfecta porque tambien trata de ajustarse a Pascal
% TODO hablar de la implementación funcional, la recursividad terminal, etc de como nuestro primer intento fue funcional y por eso se incluye de manera anecdotica
% TODO indicar como correrla de alguna forma