\section{Implementación en C}
\hspace{2em}Para las pruebas en este lenguaje se usó el compilador \texttt{gcc} en su versión 5.4.0 sobre Ubuntu Mate 16.04 (amd64).

\subsection{Descripción}
\hspace{2em}C es un lenguaje de programación de propósito general que sigue el paradigma imperativo procedural estructurado. Es un lenguaje de nivel medio ya que permite el uso de procedimientos y estructuras de alto nivel así como incluir código ensamblador en el código fuente.\\

La compilación del código fuente produce código máquina para la plataforma final. Como su principal uso fue dirigido a la creación de sistemas operativos, a día de hoy es un lenguaje multiplataforma. Sus compiladores permiten compilarlo para cualquier plataforma final sin hacer apenas cambios en el código. \\

Su sintaxis viene especificada en el estándar C, definiéndolo como lenguaje de tipado estático, débil, nominal y declarativo (manifest). La gestión de la memoria es manual, es decir, es el programador el encargado de reservar memoria dinámica y liberarla. \\

La enorme popularidad del lenguaje le ha permitido ser el que más implementaciones tiene. A día de hoy sirve de lenguaje intermedio para otros lenguajes de alto nivel como C++, C\#, Objetive-C, Go, Perl, PHP, Python, Lua y Swift. También contiene muchísimas bibliotecas externas para emular comportamientos de otros lenguajes, como la gestión de memoria automática, orientación a objetos mediante GObject e incluso poder usar funciones lamda.
\subsection{Análisis}

\hspace{2em}C y Pascal comparten el mismo paradigma y la misma forma de trabajo, por lo que la adaptación a C ha resultado en un código casi idéntico al proporcionado en la implementación en Pascal. Sólo nos queda comentar un pequeños detalles que han marcado la diferencia entre los dos lenguajes. \\

El primero es que C no presenta un método estructurado en el propio lenguaje para definir un módulo. La solución más parecida es incluir en un archivo \texttt{.h} aparte las definiciones de tipos de variables y funciones que puede usar el programa principal, y en un archivo \texttt{.c} la implementación tanto de las funciones visibles al programa principal como de las funciones internas del módulo (como las formas recursivas e iterativas de inserción, borrado y búsqueda, y la función para crear un nuevo nodo e imprimir un error cuando no hay espacio). Esto no evita que el programador pueda hacer implementaciones en el archivo de cabecera, cosa que Pascal restringe más mediante la definición de módulos. \\

Otro problema que nos encontramos es que C no tiene una forma de indicar si los argumentos de las funciones son pasados por valor o por referencia tan sencilla y cómoda de utilizar como el VAR de Pascal. En su lugar, el paso por referencia se realiza pasando un puntero al parámetro (*********los parámetros como punteros), lo cual resulta un engorro de cara a la programación y la legibilidad del código. \\

Por último, para ser fieles a la implementación de Pascal, hemos tenido que usar la biblioteca \texttt{stdbol} debido a que C no contiene el tipo primitivo \texttt{boolean}. \\ % TODO sino que utiliza 0 como false y cualquier otro valor como true (era solo con enteros?)

Con esto podemos concluir que Pascal es más estructurado y de mayor nivel de abstracción que C, por lo que realmente no hay mejoras que C pueda hacer con respecto a Pascal en este caso. % TODO ya que el problema que se nos plantea (implementar ABB) es una tarea de abstracción a la que las capacidades de bajo nivel de C (mayores capacidades que Pascal, va, no?) no pueden aportar nada