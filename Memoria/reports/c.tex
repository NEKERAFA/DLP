\section{C' Implementation} % Implementación en C
\hspace{2em}Compiler used: \texttt{gcc}.\\

Operating System: Ubuntu Mate 16.04 (amd64). % Para las pruebas en este lenguaje se usó el compilador \texttt{gcc} en su versión 5.4.0 sobre Ubuntu Mate 16.04 (amd64).

\subsection{Description}
\hspace{2em}C is a general-purpose programming language that follows the imperative procedural structured paradigm. It is a medium-level language that allows the use of procedures and high-level structures as well as the inclusion of assembly code in the source code. Its initial main use was the creation of Operating Systems.\\ % C es un lenguaje de programación de propósito general que sigue el paradigma imperativo procedural estructurado. Es un lenguaje de nivel medio ya que permite el uso de procedimientos y estructuras de alto nivel así como incluir código ensamblador en el código fuente.\\

Compilation of source code produces machine code for the final platform. It is a cross-platform language, so its compilers allow compilation to a lot of final platforms making few or no changes in the source code. % La compilación del código fuente produce código máquina para la plataforma final. Como su principal uso fue dirigido a la creación de sistemas operativos, a día de hoy es un lenguaje multiplataforma. Sus compiladores permiten compilarlo para cualquier plataforma final sin hacer apenas cambios en el código.\\

The C standard defines C's typing as static, weak, manifest and nominal. The memory management is manual, that is, the programmer is responsible of reserving and freeing dynamic memory. % Su sintaxis viene especificada en el estándar C, definiéndolo como lenguaje de tipado estático, débil, nominal y declarativo (manifest). La gestión de la memoria es manual, es decir, es el programador el encargado de reservar memoria dinámica y liberarla. \\

C's popularity has resulted in the greatest amount of implementations among programming languages. Nowadays, it serves as an intermediate language for other high-level languages such as C++, C\#, Objective-C, Go, Perl, PHP, Python, Lua and Swift. It also has many external libraries to emulate features from other languages, such as automatic memory management, object-orientation through GObject or even lambda-functions. % La enorme popularidad del lenguaje le ha permitido ser el que más implementaciones tiene. A día de hoy sirve de lenguaje intermedio para otros lenguajes de alto nivel como C++, C\#, Objetive-C, Go, Perl, PHP, Python, Lua y Swift. También contiene muchísimas bibliotecas externas para emular comportamientos de otros lenguajes, como la gestión de memoria automática, orientación a objetos mediante GObject e incluso poder usar funciones lamda.
\subsection{Analysis}

\hspace{2em}C and Pascal share the same paradigm and work method, so the adaptation has resulted in code almost identical to that of the implementation in Pascal. The only thing left is to note some details that supposed the diference between both languages. % C y Pascal comparten el mismo paradigma y la misma forma de trabajo, por lo que la adaptación a C ha resultado en un código casi idéntico al proporcionado en la implementación en Pascal. Sólo nos queda comentar unos pequeños detalles que han marcado la diferencia entre los dos lenguajes. \\

In the first place, C does not have a really structured way to define a module. The most similar solution is to include in a \texttt{.h} file the definitions of variable types and functions the main program can use and in a \texttt{.c} file the implementation of both the public and the private functions (like the recursive and iterative versions of insertion, deletion and search, as well as the function to create a new node and print an error when there is no space left). This does not prevent the programmer from implementing functions in the header file, something that Pascal restricts more by its module definition.\\ % El primero es que C no presenta un método estructurado en el propio lenguaje para definir un módulo. La solución más parecida es incluir en un archivo \texttt{.h} aparte las definiciones de tipos de variables y funciones que puede usar el programa principal, y en un archivo \texttt{.c} la implementación tanto de las funciones visibles al programa principal como de las funciones internas del módulo (como las formas recursivas e iterativas de inserción, borrado y búsqueda, y la función para crear un nuevo nodo e imprimir un error cuando no hay espacio). Esto no evita que el programador pueda hacer implementaciones en el archivo de cabecera, cosa que Pascal restringe más mediante la definición de módulos. \\

Another issue is that C does not have a way to indicate if arguments are passed by value or by reference as simple and comfortable as Pascal's \texttt{VAR}. Instead of this key word, arguments passed by referencia need to be passed as a pointer, which is annoying with respect to the task of programming and reading the code (y se nota ques estoy muriendo por dentro porque esta traduccion es una mierda) % Otro problema que nos encontramos es que C no tiene una forma de indicar si los argumentos de las funciones son pasados por valor o por referencia tan sencilla y cómoda de utilizar como el VAR de Pascal. En su lugar, el paso por referencia se realiza pasando un puntero al parámetro (*********los parámetros como punteros), lo cual resulta un engorro de cara a la programación y la legibilidad del código. \\

Finally, as we needed to make it similar to Pascal's code, we used the library \texttt{stdbool} in order to have \texttt{boolean} type, as C does not have it by default. % Por último, para ser fieles a la implementación de Pascal, hemos tenido que usar la biblioteca \texttt{stdbool} debido a que C no contiene el tipo primitivo \texttt{boolean}. \\ 
% TODO sino que utiliza 0 como false y cualquier otro valor como true (era solo con enteros?)

We can conclude that Pascal is more structured and has a higher abstraction level than C, so there are actually no enhances C could make with respect to Pascal in this case. % Con esto podemos concluir que Pascal es más estructurado y de mayor nivel de abstracción que C, por lo que realmente no hay mejoras que C pueda hacer con respecto a Pascal en este caso. 
% TODO ya que el problema que se nos plantea (implementar ABB) es una tarea de abstracción a la que las capacidades de bajo nivel de C (mayores capacidades que Pascal, va, no?) no pueden aportar nada