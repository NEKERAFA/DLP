\section{Python} % Implementación en Python

\hspace{1.5em}Interpreter used: \texttt{python3} version 3.5.2.

\subsection{Language Survey} % Descripción

Python es un lenguaje de programación de propósito general multiparadigma. Es un lenguaje de alto nivel e interpretado, que nació con la filosofía de enfatizar la legibilidad del código y una sintaxis sencilla y compacta para que los desarrolladores programaran con la menor cantidad de lineas de código posible en comparación a otros lenguajes como C++ o Java. \\

Python usa un tipado fuerte y dinámico y no declarativo, permitiendo duck typing. Contiene un recolector de memoria automática, siendo el intérprete el encargado de reservar y eliminar la memoria según procesa el código. \\

La implementación de referencia del intérprete de Python es CPython, el cual es open source y es administrado por la Python Software Foundation.

\subsection{Analysis}

\subsubsection{Advantages and Disadvantages} % Análisis de ventajas y desventajas

La primera diferencia que nos encontramos en Python con respecto a Pascal es que Python es interpretado, permitiendo no tener que compilar el código cada vez que se modifica. Con respecto a esto podemos afirmar que el propio intérprete nos presenta más información cuando se produce un error que en el resto de lenguajes analizados, muy a la par del intérprete bytecode de Java. \\

Otra cosa que podemos comentar es que en Python no tenemos gestión manual de memoria, por lo que tenemos las mismas implicaciones de Java y OCaml que comentar en este aspecto. \\

Por otro lado, los parámetros de las funciones son pasados por referencia en Python. Esto nos ha permitido simplificar la forma de trabajar con el árbol, pareciéndose a la implementación de Pascal en muchos casos. \\

Un hecho en contra a comentar de este lenguaje es que al no existir método alguno de declarar el tipo de las variables, no hay forma de forzar al programador a que pase unos tipos de variables concretos a la función, dando error en ejecución. En nuestro caso, esto también implica en que el programador puede intentar insertar claves de distinto tipo. \\

Como ventaja de esto último, debido al carecer de forma de declarar los tipos, la propia implementación permite usar como clave cualquier tipo que permita usar expresiones de comparación. \\

Otro hecho en contra es que el propio lenguaje no tiene forma de definir variables o funciones locales / privadas a menos que sean dentro de diferentes scopes (variable definidas dentro de una función). Esto supone que todas las funciones definidas en el módulo principal son públicas a quien lo use, sin restricción alguna.

\subsubsection{Implementation} % Análisis de implementación

La principal diferencia en la implementación con respecto a todos los demás lenguajes analizados ha sido la traducción de tipos. En Python las variables son de tipo dinámico y no se declaran, por lo que se ha eliminado toda la definición de tipos presente en los demás lenguajes. \\

Debido a esto, hemos definido el árbol como un diccionario (un array asociativo) que contiene tres claves: \texttt{key} que guarda la clave del nodo, \texttt{left} y \texttt{right} que los diccionarios de los hijos izquierdo y derecho.

Con respecto a las funciones, podemos comentar de su implementación que es casi directa a excepción de las siguientes funciones:
\begin{itemize}
	\item \texttt{crearNodoA}: Como ya comentamos, en Python no se puede asignar memoria manualmente, así que esta función solo crea un diccionario con la clave \texttt{key} a \texttt{None} y las claves \texttt{left} y \texttt{right} como diccionarios vacíos. Cabe destacar que esta función no se puede hacer pública.
	\item \texttt{arbolVacio}: Devuelve un diccionario vacío en vez de un valor nulo.
	\item \texttt{insertar\_r}: La única diferencia con Pascal es que en Python, si se asigna otro valor a un parámetro, el scope pasa a ser el de la función, por lo que, para insertar en el nodo hemos tenido que asignar los nuevos valores al nodo
	\item \texttt{insertar\_i}: Pasa algo parecido a \texttt{insertar\_r} en el momento de asignarlo al árbol.
	\item \texttt{sup2}: Cuando subimos el árbol izquierdo del nodo más a la derecha, hacemos una comprobación de este para que si está vacío para eliminar las claves, o hacer algo parecido a \texttt{insertar\_r} cuando contiene datos.
	\item \texttt{eliminar\_r}: Pasa algo parecido a \texttt{sup2} cuando subimos el único hijo del nodo a eliminar.
\end{itemize}

\subsubsection{Possible Enhancements} % Posibles mejoras

% TODO usar una clase por nodos