\section{Python} % Implementación en Python
\hspace{1.5em}Interpreter used: \texttt{python3} version 3.5.2.

\subsection{Language Survey} % Descripción
\hspace{length}Python is a general-purpose, high-level, multiparadigm, interpreted programming language. It was created with the purpose of emphasising code readability and using a simple and compact syntax so that developers could make programs with less lines of code than other languages like C++ or Java.\\ % Python es un lenguaje de programación de propósito general multiparadigma. Es un lenguaje de alto nivel e interpretado, que nació con la filosofía de enfatizar la legibilidad del código y una sintaxis sencilla y compacta para que los desarrolladores programaran con la menor cantidad de lineas de código posible en comparación a otros lenguajes como C++ o Java. \\

Python uses a strong, dynamic, non-declarative typing, allowing duck typing. It has an automatic garbage collector, being the interpreter the responsible for allocating and freeing memory as it processes the code.\\ % Python usa un tipado fuerte y dinámico y no declarativo, permitiendo duck typing. Contiene un recolector de memoria automática, siendo el intérprete el encargado de reservar y eliminar la memoria según procesa el código. \\

Despite the interpreter having many implementations in different languages, the reference implementation is CPython, which is open source and is programmed in C. Nowadays it is managed by the Python Software Foundation. % A pesar de tener muchas implementaciones del intérprete en diferentes lenguajes, se ha acordado que la implementación de referencia sea CPython, el cual está programado en C y es open source. Actualmente lo administra la Python Software Foundation.

\subsection{Analysis}

\subsubsection{Advantages and Disadvantages} % Análisis de ventajas y desventajas
\hspace{1.5em}The first difference between Python and Pascal is that the first one is interpreted, so code is not compiled each time it is modified, saving time. Besides, the interpreter provides more information whenever an error occurs than most of the other analysed languages, with the exception of Java which provides similar information.\\ % La primera diferencia que nos encontramos en Python con respecto a Pascal es que Python es interpretado, permitiendo no tener que compilar el código cada vez que se modifica. Con respecto a esto podemos afirmar que el propio intérprete nos presenta más información cuando se produce un error que en el resto de lenguajes analizados, muy a la par del intérprete bytecode de Java. \\

The lack of manual memory management implies the same as in the other languages that share this feature.\\ % Otra cosa que podemos comentar es que en Python no tenemos gestión manual de memoria, por lo que tenemos las mismas implicaciones de Java y OCaml que comentar en este aspecto. \\

Another thing to mention is that the arguments passed by reference have allowed us to avoid using auxiliary variables such as the parent nodes used in Java and OCaml.\\ % Por otro lado, los parámetros de las funciones son pasados por referencia en Python. Esto nos ha permitido simplificar la forma de trabajar con el árbol, pareciéndose a la implementación de Pascal en muchos casos. \\

A drawback from Python is that there is no way to declare the type of variables, so there is also no way to force the programmer to pass a specific ``type'' of variable to the functions, so errors only show up at runtime. In our case, this implies that the programmer may try to insert different kinds of key in the same tree. Said drawback is, at the same time, an advantage in the sense that the same implementation allows creating trees not only for integer keys, but for any type of key that can be used in comparative expressions.\\ % Un hecho en contra a comentar de este lenguaje es que al no existir método alguno de declarar el tipo de las variables, no hay forma de forzar al programador a que pase unos tipos de variables concretos a la función, dando error en ejecución. En nuestro caso, esto también implica en que el programador puede intentar insertar claves de distinto tipo. \\

% Como ventaja de esto último, debido al carecer de forma de declarar los tipos, la propia implementación permite usar como clave cualquier tipo que permita usar expresiones de comparación. \\

Another drawback is that all functions and variables are public, except for those defined in the scope of a function. This implies that all functions defined in the module are visible from the main program, even those ones that are supposed to be private. % Otro hecho en contra es que el propio lenguaje no tiene forma de definir variables o funciones locales / privadas a menos que sean dentro de diferentes scopes (variable definidas dentro de una función). Esto supone que todas las funciones definidas en el módulo principal son públicas a quien lo use, sin restricción alguna.

\subsubsection{Implementation} % Análisis de implementación

The main difference between this implementation and the other ones is the type translation. As type is not declared, all type definition in the code is not present.\\% La principal diferencia en la implementación con respecto a todos los demás lenguajes analizados ha sido la traducción de tipos. En Python las variables son de tipo dinámico y no se declaran, por lo que se ha eliminado toda la definición de tipos presente en los demás lenguajes. \\

Taking this into account, we have defined the tree as a dictionary (associative array) that contains three keys: \texttt{key}, \texttt{left} and \texttt{right}, being the last two ones dictionaries too.\\ % Debido a esto, hemos definido el árbol como un diccionario (un array asociativo) que contiene tres claves: \texttt{key} que guarda la clave del nodo, \texttt{left} y \texttt{right} que los diccionarios de los hijos izquierdo y derecho.

With regard to functions, most of the adaptations are pretty straightforward, but we have a few exceptions:% Con respecto a las funciones, podemos comentar de su implementación que es casi directa a excepción de las siguientes funciones:
\begin{itemize}
	\item \texttt{crearNodoA}: As we cannot allocate memory manually, all this function does is to return a dictionary with \texttt{key} set to \texttt{None} and \texttt{right} and \texttt{left} set to empty dictionaries. As mentioned earlier, this function is public although it is supposed to be private.% Como ya comentamos, en Python no se puede asignar memoria manualmente, por lo que esta función lo único que hace es declarar y devolver un diccionario con la clave \texttt{key} a \texttt{None} y las claves \texttt{left} y \texttt{right} como diccionarios vacíos. Cabe destacar que esta función no se puede hacer pública debido a que en Python no hay tipos ``locales/privados''.
	\item \texttt{arbolVacio}: Returns an empty dictionary instead of a null value (which in Python would be \texttt{None}).% Devuelve un diccionario vacío en vez de un valor nulo.
	\item \texttt{insertar\_r, insertar\_i, sup2, eliminar\_r} and \texttt{eliminar\_i}: In Python, when a new value is assigned to a function parameter, it does not remain when the function ends. However, in the case of dictionaries, its entries may be modified one by one. Because of that, in order to modify the node passed as an argument, we had to assign each of the three values (key, left and right) one by one. % La única diferencia con Pascal es que en Python, si se asigna otro valor a un parámetro de la función, el scope pasa a ser local a la función. Es por eso que, para insertar en el nodo hemos tenido que asignar los nuevos valores al nodo
\end{itemize}

\subsubsection{Other approaches} % Otras aproximaciones
\hspace{1.5em}There are really no enhancements that we could make, so we shall explain another approach that Python allows. As Python is multiparadigm, we could have done an object-oriented implementation, very similar to Java's.\\% Comentar que, debido a la naturaleza de Python, las mejoras o ventajas que nos puede aportar este lenguaje se aplican al momento de implementar y codificar, por lo que no vemos como aprovechar este lenguaje de otra forma. \\

% Lo que si que hay que destacar es que, como Python es un lenguaje que soporta diferente paradigmas, se podría pensar en usar una implementación orientada a objetos definiendo el módulo como una clase estática. Esta aproximación sería muy parecida a lo comentado en Java. Cabe destacar que con ese planteamiento también podríamos encapsular el nodo como una clase en vez de como un diccionario.