\section{Python} % Implementación en Python

\hspace{1.5em}Interpreter used: \texttt{python3} version 3.5.2.

\subsection{Language Survey} % Descripción

Python es un lenguaje de programación de propósito general multiparadigma. Es un lenguaje de alto nivel e interpretado, que nació con la filosofía de enfatizar la legibilidad del código y una sintaxis sencilla y compacta para que los desarrolladores programaran con la menor cantidad de lineas de código posible en comparación a otros lenguajes como C++ o Java. \\

Python usa un tipado fuerte y dinámico y no declarativo, permitiendo duck typing. Contiene un recolector de memoria automática, siendo el intérprete el encargado de reservar y eliminar la memoria según procesa el código. \\

A pesar de tener muchas implementaciones del intérprete en diferentes lenguajes, se ha acordado que la implementación de referencia sea CPython, el cual está programado en C y es open source. Actualmente lo administra la Python Software Foundation.

\subsection{Analysis}

\subsubsection{Advantages and Disadvantages} % Análisis de ventajas y desventajas

La primera diferencia que nos encontramos en Python con respecto a Pascal es que Python es interpretado, permitiendo no tener que compilar el código cada vez que se modifica. Con respecto a esto podemos afirmar que el propio intérprete nos presenta más información cuando se produce un error que en el resto de lenguajes analizados, muy a la par del intérprete bytecode de Java. \\

Otra cosa que podemos comentar es que en Python no tenemos gestión manual de memoria, por lo que tenemos las mismas implicaciones de Java y OCaml que comentar en este aspecto. \\

Por otro lado, los parámetros de las funciones son pasados por referencia en Python. Esto nos ha permitido simplificar la forma de trabajar con el árbol, pareciéndose a la implementación de Pascal en muchos casos. \\

Un hecho en contra a comentar de este lenguaje es que al no existir método alguno de declarar el tipo de las variables, no hay forma de forzar al programador a que pase unos tipos de variables concretos a la función, dando error en ejecución. En nuestro caso, esto también implica en que el programador puede intentar insertar claves de distinto tipo. \\

Como ventaja de esto último, debido al carecer de forma de declarar los tipos, la propia implementación permite usar como clave cualquier tipo que permita usar expresiones de comparación. \\

Otro hecho en contra es que el propio lenguaje no tiene forma de definir variables o funciones locales / privadas a menos que sean dentro de diferentes scopes (variable definidas dentro de una función). Esto supone que todas las funciones definidas en el módulo principal son públicas a quien lo use, sin restricción alguna.

\subsubsection{Implementation} % Análisis de implementación

La principal diferencia en la implementación con respecto a todos los demás lenguajes analizados ha sido la traducción de tipos. En Python las variables son de tipo dinámico y no se declaran, por lo que se ha eliminado toda la definición de tipos presente en los demás lenguajes. \\

Debido a esto, hemos definido el árbol como un diccionario (un array asociativo) que contiene tres claves: \texttt{key} que guarda la clave del nodo, \texttt{left} y \texttt{right} que los diccionarios de los hijos izquierdo y derecho.

Con respecto a las funciones, podemos comentar de su implementación que es casi directa a excepción de las siguientes funciones:
\begin{itemize}
	\item \texttt{crearNodoA}: Como ya comentamos, en Python no se puede asignar memoria manualmente, por lo que esta función lo único que hace es declarar y devolver un diccionario con la clave \texttt{key} a \texttt{None} y las claves \texttt{left} y \texttt{right} como diccionarios vacíos. Cabe destacar que esta función no se puede hacer pública debido a que en Python no hay tipos ``locales/privados''.
	\item \texttt{arbolVacio}: Devuelve un diccionario vacío en vez de un valor nulo.
	\item \texttt{insertar\_r}: La única diferencia con Pascal es que en Python, si se asigna otro valor a un parámetro de la función, el scope pasa a ser local a la función. Es por eso que, para insertar en el nodo hemos tenido que asignar los nuevos valores al nodo
	\item \texttt{insertar\_i}: Pasa algo parecido a \texttt{insertar\_r} en el momento de asignar el nuevo nodo al árbol.
	\item \texttt{sup2}: Cuando subimos el árbol izquierdo del nodo más a la derecha, hacemos una comprobación de este nodo para que si está vacío eliminemos las claves del diccionario, o hacer algo parecido a \texttt{insertar\_r} cuando contiene el nodo no está vacío.
	\item \texttt{eliminar\_r}: Pasa algo parecido a \texttt{sup2} cuando subimos el único hijo del nodo a eliminar.
\end{itemize}

\subsubsection{Otras aproximaciones}

Comentar que, debido a la naturaleza de Python, las mejoras o ventajas que nos puede aportar este lenguaje se aplican al momento de implementar y codificar, por lo que no vemos como aprovechar este lenguaje de otra forma. \\

Lo que si que hay que destacar es que, como Python es un lenguaje que soporta diferente paradigmas, se podría pensar en usar una implementación orientada a objetos definiendo el módulo como una clase estática. Esta aproximación sería muy parecida a lo comentado en Java. Cabe destacar que con ese planteamiento también podríamos encapsular el nodo como una clase en vez de como un diccionario.