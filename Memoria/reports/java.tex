\section{Java's Implementation} % Implementación en Java
\hspace{2em}Compiler used: \texttt{javac} version 1.8.0\_144.\\
Operating System: Ubuntu Mate 16.04 (amd64). % Para las pruebas en este lenguaje se usó el compilador \texttt{javac} en su versión 1.8.0\_144 sobre Ubuntu Mate 16.04 (amd64).

\subsection{Language Survey} % Descripción
\hspace{2em}Java is a general-purpose, high-level programming language that is object-oriented and class-based, although the lastest versions also include some elements from another paradigms, such as lambda-functions from functional programming. Much of its syntax derives from C++, but it has fewer low-level features.\\ % Java es un lenguaje de programación de propósito general de alto nivel que sigue el paradigma de orientación a objetos basada en clases, aunque a día de hoy las últimas versiones ya incluyen elementos de otros paradigmas, como funciones lambda. \\

When compiled, source code is translated to java bytecode, which is then executed via a virtual machine (VM) specifically designed for the final platform. Thanks to this, Java programs can run in a wide variety of platforms without having to recompile them. The VM itself takes care of dynamic memory management through an automatic garbage collector, which is responsible of allocating memory when an object is created and freeing it when said object becomes unreferenced.\\ % La compilación del código fuente se traduce a bytecode java, el cual puede ser usado en cualquier plataforma y que es ejecutado sobre una máquina virtual que sí está diseñada para la plataforma final. \\

Among other characteristics, we can mention that Java's typing is strong and static, and that all method arguments are passed by value. % Su sintaxis deriva en gran medida de C++, siendo Java un lenguaje de tipado estático y fuerte (no parece tener relación la segunda mitad de la frase con la primera equisdé, voy a probar a moverla la segunda para arriba). Es la propia máquina virtual la encargada de la gestión de memoria mediante un recolector automático de basura, el cual es responsable de gestionar el ciclo de vida, reservando memoria cuando el programador crea un objeto, y liberando memoria cuando se deja de referenciar completamente el objeto usado.
% TODO comentar quizás el paso por valor de los parámetros (ya hecho, pero consultar si queda guay)
\subsection{Analysis}
% TODO en el report que corresponda (supongo que este o Python, poner que ha sido la adaptación que dio más problemas)
\subsubsection{Advantages and Disadvantages} % Análisis de ventajas y desventajas
\hspace{2em}As stated before, Java does not allow manual memory management, so pointer data types could not be ``translated'' directly. On the other hand, automatic memory management allows us to focus on the algorithms themselves, forgetting about handling lack of memory (as Java's VM will throw an \texttt{OutOfMemoryError} in such a case).\\ % Como se ha mencionado anteriormente, Java no permite la gestión manual de la memoria, por lo que los tipos de datos que eran punteros no se han podido "traducir" directamente. La gestión de memoria automática nos permite olvidarnos de las tareas de reservar espacio, gestionar la falta de memoria (ya que la propia máquina virtual de Java se encarga de lanzar la excepción \texttt{OutOfMemoryError} cuando esto sucede) y liberar la memoria, posibilitando que nos centremos más en los algoritmos en sí. (me salto partes para no repetirnos con el rollo de asignar y liberar memoria)\\

Another important issue is the argument-passing method (ni idea de si lo que acabo de poner tiene sentido lmao). As parameters are always passed by value, handling the tree structure became more complicated (we shall explain this matter in more depth in the implementation details section).\\ % Por otro lado nos encontramos con que en Java el paso de parámetros es siempre por valor y no por referencia, lo que ha ocasionado problemas que no existían en Pascal a la hora de manejar la estructura del árbol (explicaremos estos problemas más adelante cuando entremos en detalles de la implementación). \\

Finally, as we use classes instead of structs and pointers, the resulting code is higher-level and easier to read.\\ % Por último, cabe destacar que al utilizar clases y no estructuras y punteros, el código resultante es de más alto nivel y más legible.\\

\subsubsection{Implementation} % Análisis de implementación

\hspace{2em}In first place, we shall talk about the ``translation'' of data types. % En primer lugar hablaremos de la ``traducción'' de los tipos.
\begin{itemize}
	\item \texttt{tPosA}, as it is a pointer, disappears. % al ser un puntero, desaparece.
	\item \texttt{tNodoA} becomes the class \texttt{Node}, which has the same attributes the original struct had as fields. With the goal of being true (ni idea de si está bien) to the Pascal implementation, all attributes are public. % se convierte en la clase \texttt{Node}, con los mismos atributos que tenía como campos en la estructura original. Con el fin de ser fieles a la implementación en Pascal, todos los atributos son públicos.
	\item \texttt{tABB} becomes the class \texttt{Bst}\footnote{Binary Search Tree}, which only contains a \texttt{Node} attribute representing the tree root. In this way \texttt{Bst} acts as a wrapper for the structure of nodes and provides an access point to it.% se convierte en la clase \texttt{Bst}\footnote{Binary Search Tree}, el cual solo contiene un atributo de tipo \texttt{Node}. De este modo, Bst actúa como un envoltorio y punto de acceso a la estructura de nodos.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Returning to the value-passed arguments problems mentioned earlier, we have the following situation: whenever an object is passed as an argument, what the method actually receives is a copy of the pointer to that object, so all changes done to the received pointer (such as assigning it to a new object) will not remain upon the method's end. This forces us to use some sort of ``indirect pointers'', that is, we use an object which is not the one we want to modify, but contains a reference to it. For example, to delete a node, we use its parent node.\\ % Volviendo sobre los problemas de paso de parámetros mencionados anteriormente, tenemos que, en concreto, cuando un objeto se pasa como argumento, lo que se recibe es una "copia" del puntero a dicho objeto, por lo que todos los cambios realizados en ese puntero no se reflejan fuera del método. Es por esto que ha resultado necesario recurrir a "punteros indirectos" como utilizar los nodos padre para manejar a los hijos, o utilizar el objeto Bst que envuelve la raíz para insertar y eliminar la misma.\\ 

Now, let us move on to the adaptation of procedures and functions. All of them have become static methods from a utility class. The ones that were private in Pascal remain private in Java. % Ahora hablemos de la adaptación de los procedimientos y funciones. Todos ellos se han convertido en métodos estáticos de una clase de utilidad. Los procedimientos y funciones que se mantenían como privados en Pascal siguen siendo privados en Java.
% TODO decidir si poner nombre directamente en inglés
\begin{itemize}
	\item \texttt{arbolVacio}: Creates a new \texttt{Bst} object and returns it. Differs from the original implementation in that no \texttt{Bst} is passed as argument. Should it be done that way (nunca usé esta expresión así que igual está mal 3:), the \texttt{Bst} would remain unitialized (palabra sacada de la nada (?)) due to the passed-by-value arguments in Java. % Crea un nuevo objeto Bst y lo devuelve. Difiere de la implementación en Pascal en que no inicializa un árbol pasado por parámetro, ya que si la inicialización se hiciera de esta forma no se reflejaría fuera del método por el paso de parámetros por valor de Java.
	\item \texttt{hijoIzquierdo}, \texttt{hijoDerecho} and \texttt{raiz}: They return the pertinent attributes from the root node of the tree. For the first two ones, the nodes are returned wrapped in a \texttt{Bst} object to follow Pascal specifications with respect to the returned type. % Devuelven los atributos correspondientes del nodo alojado en la raíz del árbol. En el caso de los dos primeros, se devuelven envueltos en un nuevo objeto Bst para seguir la interfaz declarada en Pascal en cuanto al tipo devuelto.
	\item \texttt{esArbolVacio}: Checks if the root node inside the \texttt{Bst} is \texttt{null}. % Se comprueba si el nodo alojado en la raíz es null.
	\item \texttt{insertarR}: Instead of traversing the tree with a \texttt{Bst} (the equivalent to the \texttt{tABB}), we use a \texttt{Node}. Besides, we add a new argument \texttt{Bst} representing the tree whose root node is the parent node of our \texttt{Node} argument. Remember that in this point, our \texttt{Node} argument is just a copy of the pointer we want to modify. By using the parent node, we can access the pointer we actually want to change. Initially, \texttt{Bst} is the tree we want to insert into, so that we have real access to the root node (and not a copy) in the case we need to insert in there. % En lugar de recorrer el árbol con el equivalente a un tABB, utilizamos un Node. Además, añadimos un nuevo argumento, de tipo Bst, representando el árbol cuya raíz es el nodo padre del Node. Debido al paso por valor de Java, el argumento Node no es más que una copia del puntero que queremos actualizar, por lo que no podemos hacer los cambios sobre este argumento. En su lugar, utilizamos el Bst padre, que sí contiene el puntero real que queremos actualizar accesible a través de su raíz. Inicialmente, Bst es el propio árbol en el que hay que insertar, lo que nos permite tener acceso real a la raíz en caso de que no exista.
	\item \texttt{insertarI}: In a similar way to the mentioned above, receiving the tree itself allows to insert the root if it did not exist. % De modo similar a la anterior, recibir el propio árbol nos permite insertar la raíz si esta no existiera, lo que resultaría imposible de recibir directamente el nodo raíz. (paso de repetirme)
	\item \texttt{buscarR} y \texttt{buscarI}: The found node is wrapped in a \texttt{Bst} object in order to follow Pascal's interface. % Al igual que con \texttt{hijoIzquierdo} y \texttt{hijoDerecho}, el nodo a devolver se envuelve en un objeto Bst para cumplir con la interfaz de Pascal.
	\item \texttt{sup2}: This procedure's adaptation receives 3 parameters. 
		\begin{itemize}
			\item \textit{Node to be deleted}, so that we can replace its key with the greatest one from its left subtree.
			\item \textit{Node} used as an iterator to traverse the tree to the right.
			\item \textit{Parent node} of the iterator node. This way we can move the iterator's left subtree to its parent.
		\end{itemize} % La adaptación de este procedimiento recibe tres argumentos. Por un lado, el nodo que se va a eliminar para que podamos cambiar su clave por la mayor clave de su subárbol izquierdo. Por otro lado, el nodo que se utiliza para ir recorriendo el árbol hacia la derecha y el padre de dicho nodo. De esta forma, podemos mover los hijos izquierdos del nodo al nodo padre, algo que, de nuevo, no podríamos hacer si sólo tuviéramos el nodo en sí. 
	% TODO Decisión respecto a si función lambda o no cuando esté tomada
	\item \texttt{eliminarR}: This method also receives 3 arguments.
		\begin{itemize}
			\item \textit{Key} to delete.
			\item \textit{Node} to use as an iterator to search for the node to remove.
			\item \textit{Bst} whose root is the parent node of the iterator node.
		\end{itemize} 
	More changes appear in the removal of a node with at most one child, as we need to check if this node is the root of the whole tree, and in other case if the node is a left or a right child, because we keep making the reorganisation through the parent. % Este método, además de la clave a eliminar, recibe un objeto Node que se usa para recorrer el árbol en busca del nodo a eliminar y un objeto Bst cuya raíz es el nodo padre, en la línea de insertR. Las diferencias entre la adaptación y el original se concentran en la eliminación de un nodo que tiene un hijo como mucho. Necesitamos añadir comprobaciones de si estamos eliminando la raíz del árbol completo, y en caso contrario si el nodo que estamos eliminando era un hijo izquierdo o derecho, ya que la reestructuración del árbol seguimos haciéndola desde el padre.
	\item \texttt{eliminarI}: Adapted from Pascal's implementation without relevant changes. % Se adaptó de Pascal sin cambios relevantes.
	
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Possible Enhancements} % Posibles mejoras
\hspace{2em}Due to the requirement to respect the implementation defined in Pascal, we coul not take advantage of some features of object-orientation that would have made Java's implementation of the tree more natural and safe. % Al tener que respetar la implementación de Pascal, no han podido aprovecharse algunas de las ventajas de la orientación a objetos que habrían hecho la implementación en Java más natural y segura.\\

\begin{itemize}
	\item The attributes could have been private, implementing only the getter and setter methods needed with the apropiate visibility so that the tree could not be modified from the main program without using the method provided to that effect. This way we could guarantee that the tree always preserved the structure of a binary search tree. % Los atributos podrían haberse puesto como privados, implementando tan solo los getters y setters necesarios con la visibilidad apropiada para que el árbol no pudiera ser modificado desde el programa principal sin usar los métodos definidos para tal efecto. De esta forma, podría garantizarse que el árbol siempre mantuviera la estructura propia de un árbol binario de búsqueda.
	\item Methods could have been owned by the Bst class itself. This woul imply that methods would not need to receive the tree as an argument, and the resulting code would be more natural for an object-oriented language. % Los métodos podrían haberse implementado como propios de la clase Bst, en lugar de en una clase aparte. De este modo recibirían menos parámetros (ya que no necesitarían recibir el árbol a tratar) y la implementación sería más natural y propia de la orientación a objetos.
	\item Java allows us to define parametric classes, which would result in defining just one Bst tha would be valid for all types of keys (or at least, all key types with a comparation method). The key type would then be determined at the moment of declaring each Bst variable. % Java nos permite definir las clases como paramétricas, lo que nos permitiría no tener que definir un árbol binario de búsqueda para cada tipo de clave, sino uno general en el que el tipo de clave se especificaría en el momento de declarar la variable Bst.
\end{itemize}