- Compilador Java
  javac 1.8.0_144

- tPosA es un puntero, y en Java no hay gestión de memoria manual, por lo que desaparece
- tNodoA se transforma en un objeto para representar el nodo
- tABB se transforma en un objeto para representar el árbol
- tClave lo traducimos en hacer el árbol de modo paramétrico / lo dejamos como Integer (necesario
que sea envoltorio para tener un árbol vacío)
- Nuestro objeto nodo tiene atributos key, rightChild y leftChild
- Nuestro objeto árbol tiene un atributo nodo
- El objeto nodo tiene getters públicos y setters de visibilidad paquete (para que no se pueda modificar desde el 
programa principal)
- Para devolver los hijos derecho e izquierdo, envolvemos sus nodos en un objeto Bst
- Suprimimos error y crearNodo porque tenemos el OutOfMemoryError que Java gestiona de manera automática
- ArbolVacio es el constructor por defecto (todos los atributos a null)
- Las distintas versiones iterativas y recursivas de los métodos se implementan como privadas, y sólo un método
"envoltorio" se pone como público
- Si los setters privados no funcionaran, poner visibilidad paquete/protected para que no se pueda tocar desde el 
programa principal
- Probar a conseguir una clave Integer y modificarla y ver qué pasa
- esArbolVacio comprueba que key == null
- Al eliminar, poner el nodo a null, hay que hacerlo desde el padre
- El método sup2 pasa a ser privado en vez de anidado, tenemos que devolver el padre del nodo más a la derecha
para poder acceder a la clave de dicho nodo y cambiarla con la del nodo a eliminar, y a la vez poder enganchar los
hijos del nodo encontrado con el resto del árbol (ie su padre)
	-> En el caso de la raíz hay que cambiar root por el nodo hijo. Es el único caso en el que
	es necesario usar el propio árbol
	-> También se puede hacer con una función lambda
	-> En el resto de eliminar_r la adaptación es directa

- Plantearse un constructor que reciba un Integer

- Insertar_i no empieza creando un Bst porque si el árbol está vacío no lo necesita
- La versión recursiva de insertar y buscar necesita más argumentos que la iterativa

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

- En la versión recursiva de Insertar hay que crear los hijos si no existieran antes de llamar de nuevo a la función.
- En la versión iterativa de Insertar hay que crear los hijos si no existieran al momento de saltar al hijo.
- Se ponen todos los métodos públicos dde nodo para que el código sea más parecido a Pascal.
- Se asume que el arbol no va a tener una raiz nula siempre que se maneje por las funciones definidas.
- Como arbol vacio es nodo null, necesitamos un puntero indirecto (Bst) para insertar un nuevo nodo

